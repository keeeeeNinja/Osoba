# FigmaのModel Context Protocol（MCP）サーバーに関する詳細レポート

## 1. Figmaで利用可能なMCPサーバーの種類と設定方法、主な利用目的

**MCPサーバーの種類:** 2025年現在、Figmaで利用可能なMCPサーバーには以下の2種類があります。

- **公式「Dev Mode MCPサーバー」(Figma提供):** Figmaデスクトップアプリ内で動作する公式サーバーです【1†L129-L137】。Dev Mode機能（Professional以上の有料プランのDevまたはFullシート）で利用可能なベータ版機能であり、FigmaデザインファイルからLLMへのコンテキスト提供を標準化された方法で行います【1†L121-L129】【20†L413-L420】。デスクトップ版Figmaの環境設定から「Dev Mode MCP Serverを有効化」を選ぶことでローカルに起動し、`http://127.0.0.1:3845/sse`で待ち受けます【1†L163-L171】【20†L417-L425】。この公式サーバーは、AIによる**コード自動生成をデザイン情報に基づいて支援**する目的で作られており【1†L139-L148】、具体的には次のような機能を提供します【1†L139-L148】:

   - **選択フレームからのコード生成:** Figma上で選択したフレームをReact+Tailwind CSS（初期設定）など指定フレームワークのコードにエクスポートする【1†L139-L146】【6†L314-L323】。プロダクトチームが新機能を実装する際、デザインに沿ったコードのたたき台を自動生成できます。
   - **デザインコンテキストの抽出:** デザインで使われている変数（カラーや間隔などのトークン）、コンポーネント階層、レイアウト情報をIDEに取り込み参照可能にします【1†L146-L154】。これによりデザインシステムやコンポーネントベースのワークフローで、設計とコードの整合性を保ちやすくなります。
   - **コードコネクト (Code Connect):** デザイン内のコンポーネントと既存コードベースの対応関係を提供し、AIが生成コード内で実プロジェクトのコンポーネントや変数を再利用できるようにします【1†L151-L158】【5†L189-L197】。これにより、生成されるコードが既存コードベースと一貫した命名・構造になり、品質が向上します。

- **コミュニティ提供のMCPサーバー:** 公式サーバー以外にも、有志や企業により提供されるオープンソースのMCPサーバー実装があります。例えば**Framelink Figma MCPサーバー**（GLips氏によるGithubプロジェクト）では、FigmaのWeb APIを通じてデザインデータを取得し、AIコード補助ツール（Cursor等）にレイアウト情報を提供します【3†L338-L347】。このサーバーは**Node.js製のCLIサーバー**として提供され、Figma APIトークンを用いてFigmaファイルに直接アクセスできます【3†L377-L384】（Figmaアクセス用の個人トークンの発行が必要【3†L377-L384】）。FramelinkサーバーはFigma APIから取得した生のJSONをLLMが扱いやすい簡潔な形に変換し、**デザインレイアウトやスタイルの要点だけをLLMに渡す**点が特徴です【3†L353-L362】。Cursor等のチャットエージェントでFigmaファイルのURLを貼り付けて指示すると、このサーバーが**該当ノードのメタデータ（レイアウト座標、スタイル、テキスト等）を抽出し提供**します【3†L355-L364】。スクリーンショットを貼り付けて推測させるアプローチと比べて遥かに正確にデザインをコード化できることが報告されています【3†L338-L347】。なお、コミュニティ製のサーバーとして他にもGlamaやSmitheryなどからFigma MCPサーバー実装が公開されており、CursorやWindsurf、Clineといった各種AIコードツールで利用できます【17†L451-L459】。以下は代表的なMCPサーバーの比較です。

| MCPサーバー名             | 提供元・種類          | セットアップ方法・要件                                             | 主な利用目的・特徴                                                     |
| ------------------------ | --------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------------------- |
| **Figma Dev Mode MCP**   | Figma公式 (Beta機能)  | Figmaデスクトップアプリの環境設定で有効化。Dev Mode利用可能なプランと最新デスクトップアプリが必要【1†L121-L129】【20†L413-L420】。有効化後ローカルの`127.0.0.1:3845/sse`で稼働【1†L168-L172】。MCP対応エディタ（VS Code, Cursor等）で接続設定【1†L125-L133】【1†L189-L198】。 | デザインからの**コーディング支援**: 選択フレームをReact等のコードに生成、デザイン変数・コンポーネント情報の提供、Code Connect連携による既存コード再利用支援【1†L139-L148】【5†L189-L197】。 |
| **Framelink Figma MCP**  | GLips (OSSコミュニティ)| Node.js製CLIサーバー（パッケージ名:`figma-developer-mcp`）。Figma APIトークンを取得し、Cursorの設定ファイル（`mcp.json`等）にコマンド経由で登録して起動【3†L381-L389】。例: `npx -y figma-developer-mcp --figma-api-key=YOUR-KEY --stdio`で起動。                        | **デザイン情報提供の軽量サーバー**: Figma APIから取得したフレーム情報を**必要最低限のレイアウト・スタイルデータに整理**してLLMに渡す【3†L353-L362】。Cursor等でFigmaリンクを与えるとレイアウトメタデータを提供し、スクショ貼付より高精度にUIを再現可能【3†L338-L347】。 |

*（※その他、TimHolden氏や1yhy氏による実装など複数の非公式MCPサーバーが存在し、CursorやClaude Codeで利用可能です【17†L451-L459】。公式サーバーが利用できない場合の代替手段として活用できます【20†L413-L420】。）*

## 2. Cursorエディタとの連携方法と、MCPを活用したプロジェクトの進め方

**Cursorとの連携設定:** CursorはMCPクライアント機能を持つAIコードエディタで、Figma MCPサーバーと直接連携できます。設定手順は以下の通りです【6†L214-L223】。

1. **グローバルMCPサーバーの追加:** Cursorの「Settings → Cursor Settings」の中にある**MCP**タブを開き、「+ Add new global MCP server」をクリックします【6†L214-L222】。  
2. **Figmaサーバーの設定:** 表示される設定フィールドに、Figma MCPサーバーの情報をJSON形式で入力して保存します。例として公式サーバー利用の場合、以下のように記述します【6†L222-L230】:

   ```json
   {
     "mcpServers": {
       "Figma": {
         "url": "http://127.0.0.1:3845/sse"
       }
     }
   }
   ``` 

   上記の設定で、ローカルで稼働中のFigma Dev Mode MCPサーバーにCursorが接続します【6†L222-L230】。（コミュニティ製サーバーを使う場合は、該当サーバーの起動コマンドやURLを指定します。）

3. **エージェントの有効化:** CursorではチャットAIの動作モードとして**Agentモード**を使用します（詳細は後述）。Cursor設定でMCPサーバーを追加した後、Cursorのチャット画面をAgentモードに切り替えると、利用可能なMCPツールが一覧に表示されます【14†L19-L27】【6†L298-L307】。

**プロジェクトでの活用ワークフロー:** 実際のフロントエンド開発において、Figma MCPとCursorを組み合わせることで、デザインからコードへの変換作業を半自動化できます。一般的な進め方は次のようになります。

- **(1) デザインの準備:** まずFigma上で実装対象のUIデザインを用意します。自分のプロジェクトのデザインファイルを使うのが理想ですが、手元にない場合はFigma Communityから公開デザイン（例: Material Design Kit等）を取得しても構いません【20†L397-L405】。**Figmaデスクトップアプリで当該デザインファイルを開き、実装したいフレームやコンポーネントを選択**します。MCPサーバーは選択中のオブジェクトの情報のみを提供するため、**必ず一度に1つのフレームまたはレイヤーを選択**してください【23†L475-L483】。

- **(2) MCPサーバーの起動:** Figmaデスクトップアプリのメニューから「Preferences > Enable Dev Mode MCP Server」を有効化し、ローカルMCPサーバーを起動します【20†L417-L425】。起動後、前述の`http://127.0.0.1:3845/sse`で受け付けていることを確認します（Figma画面下部に「Server running」の通知が表示されます【1†L165-L172】）。

- **(3) Cursorエディタ側の準備:** Cursorに先ほど追加したFigma MCPサーバー設定が有効になっていることを確認します。Cursor上で新しいエージェントチャットを開き、**プロジェクトのコードリポジトリ**もロードしておきます（あらかじめNext.jsなどで空のプロジェクトを作成し開いておくと良いでしょう【23†L470-L478】）。これにより、AIは生成コードを既存プロジェクト内に挿入できます。

- **(4) デザインのコンテキスト提供:** Cursorのエージェントチャットで、以下のいずれかの方法でFigmaデザインをAIに認識させます【6†L294-L303】。  
  - **選択状態の利用:** Figmaで対象フレームを選択したまま、CursorのAIに「現在選択しているデザインをコード実装してください」といったプロンプトを送ります。CursorのエージェントはMCP経由で現在選択中ノードの情報（レイアウトJSONや変数一覧など）を取得し、応答に反映します【6†L294-L302】。  
  - **URLの貼り付け:** または、Figmaで対象フレームを右クリックして「リンクをコピー」し、そのURLをチャットプロンプトに含めます（例：「このFigmaフレーム（<URL>）をReactコンポーネントとして実装して」）【6†L302-L310】。エージェントはURLからノードIDを抽出し、対応するデザイン情報をMCPサーバーから取得します【6†L304-L310】。  

- **(5) コード生成の指示:** デザインコンテキストが連携できたら、AIに対して具体的な指示を与えます。例えば「このデザインを用いてホームページのコードを置き換えてください。これはチャットアプリのUIです。」とプロンプトを送ると、AIは選択中デザインを元にコードを書き始めます【23†L479-L487】。デフォルトではMCPサーバーの`get_code`ツールにより**React + Tailwind CSS構成のコード**が生成されますが、プロンプト内で「Vueで生成して」「HTML/CSSで生成して」のようにフレームワークを指定することも可能です【6†L314-L323】。また「src/components/ui内の既存コンポーネントを使って」などと伝えると、AIはCode Connect情報を参照して既存コンポーネントを利用したコードを提案します【6†L323-L331】。

- **(6) コードの確認と修正:** AIがコードを生成し終えたら、人間の開発者がその出力を確認します。初回の出力ではUIの**大枠となる約数百行のコード**（例: Reactコンポーネントと対応CSS）がまとめて生成されますが、完全ではないことが多いです。実際の事例では、Claudeモデルを用いて**約4分間でReact 215行＋CSS 350行程度のコード**が生成されましたが、デザインと比べ「ピクセル完璧ではなく、一部ダミーデータのまま、ボタンも未実装」でした【23†L479-L487】【23†L482-L490】。このため、**追加のプロンプト**で機能の補完やコードのクリーンナップを指示し、数回の対話でコード品質を高めます【23†L483-L490】。例えば「このボタンにクリックイベントを追加してデータを表示してください」「生成されたCSSの魔法数を減らしてください」といった具合です。AIが出力したコードは**開発者自身も手を入れて調整**する必要があります【23†L483-L490】。特にレイアウトの微調整（余白値の統一等）やアクセシビリティ対応は、自動生成コードでは不完全な場合が多いため、人手で整える工程を組み込みます。

- **(7) 繰り返しと統合:** 上記の流れを、画面ごと・コンポーネントごとに繰り返していきます。大規模な画面は一度に処理せず、**UIを論理的なパーツに分割して小刻みに生成→統合**する方が安定します【8†L519-L528】。生成された複数のコンポーネントコードをプロジェクトに統合し、ビルド・実行して実際の画面とFigmaデザインを見比べながら微修正していきます。  
  この一連のプロセスにより、デザインに沿ったコードを**従来より迅速に叩き台として生成**し、開発者は調整やビジネスロジック実装など**付加価値の高い作業に集中**できるようになります【23†L487-L495】【23†L498-L506】。

**補足:** Figma MCPサーバーを活用する際は、Figmaの**Code Connect**機能を併用することが推奨されます。Code Connectにより、Figma内のデザインコンポーネントと実際のコードコンポーネントをマッピングしておくと、「例えばFigma上でButtonコンポーネントを使っている場合に、その対応コード（例:`components/Button.tsx`）へのパスをAIに教える」といったことが可能です【5†L189-L197】。これによりAIは新規コードを書くのではなく既存の`Button`をインポートして使用するコードを生成でき、デザインと実装の整合性が飛躍的に向上します【5†L189-L197】【23†L503-L510】。また、プロジェクト固有の文脈（命名規則や使用してほしいユーティリティ関数等）を**Cursorのルールファイル**やガイド文書（Markdown）であらかじめ用意しておき、必要に応じてAIに参照させるといった工夫も効果的です【23†L494-L502】。このように追加のコンテキストを与えることで、より精度の高いコード生成が可能になります。

## 3. MCP利用時にエージェントモードは必要か？AutoモードでのMCP対話可否

**エージェントモードの必要性:** MCPサーバーと対話するには、**原則としてエージェントモードが必要**です。エージェントモードとは、AIが外部ツール（MCPサーバーが提供する各種ツール）を呼び出しながら動作するモードを指します。VS CodeのGitHub Copilot ChatやCursorのAgentモードでは、この**ツール呼び出し（関数呼び出し）的な拡張**が可能になり、チャットAIがユーザ要求に応じてMCPサーバー上の`get_code`や`get_variable_defs`等のツールを裏で実行し、結果を踏まえて回答する仕組みです【1†L200-L208】【6†L288-L296】。一方、通常のシンプルなチャット（AutoモードやAskモードなど、ツールを使わないモード）ではAIは自分の内部知識とプロンプト内の情報のみで回答し、外部のMCPサーバーへ自発的にアクセスすることはありません。そのため、**MCPで提供されるデザインコンテキストを利用するにはAgentモードが不可欠**です【14†L41-L48】。

Cursorの場合、モード選択に「Agent」「Ask」「Manual」などがありますが、このうち**AgentモードだけがMCPツールの使用をサポート**しています【14†L19-L27】【14†L20-L23】。実際、Cursor開発者フォーラムでも「MCPツールを使うにはAgentモードを使用する必要がある」と明言されています【14†L41-L48】。VS Codeでも、Copilot ChatをAgentモード（Copilot Xの一部機能）で動かすことでMCPツールが利用可能になります【1†L199-L207】。

**Autoモードでの対話可否:** ここで言う「Autoモード」が何を指すかによりますが、一般に**ユーザーの介入なしに自動で進行するモード**や**ツールを使わない通常チャットモード**を意味する場合、MCPとのやり取りはできません。AIがMCPサーバーからデータを取得するには、それを呼び出す明示的または暗黙のトリガーが必要ですが、通常モードではそうした仕組みが無いためです。【14†L19-L27】（Cursorの「Askモード」は読み取り専用のQ&A用途でMCP非対応、Manualモードも自動ツール呼び出しは行いません【13†L113-L121】。）

ただし、**Agentモード内における自動実行設定**は可能です。Cursorではエージェントがツールを使う際に毎回ユーザー承認を求めるのが基本ですが、設定で「Auto-run（Yoloモード）」を有効にすると**ツール実行の都度確認を省略して自動進行**させることができます【10†L219-L227】。これにより、エージェントがユーザープロンプトを受けた後にMCPサーバーの`get_code`等を**自動承認のもと即座に実行し、結果を取得して回答**するため、対話がスムーズになります【10†L219-L227】。重要な点は、このAuto-runはあくまで**Agentモード内の設定**であり、Agentモードを使っている前提でMCPツールの自動利用を許可する機能だということです。従って、「Autoモード」という独立したモードでMCPと対話することはできず、**Agentモードを使用することが前提**となります【14†L41-L48】。

まとめると、**MCPサーバーを活用するにはエージェントモードが必須**であり、CursorやVS CodeではAgentモードでMCPサーバーを登録・有効化してください。Auto-run設定を併用すれば逐一の許可なしにツールを実行できますが、それもAgentモード内での動作です【10†L219-L227】。通常チャットモードではMCPの恩恵を受けられない点に注意が必要です。

## 4. MCP経由で利用できるAIモデルの種類と制限（GPT-4、Claudeなど）

**利用可能なモデルの種類:** MCP自体はモデルに依存しないプロトコルですが、実際にMCPを活用するAI開発支援ツールでは**主要な大規模言語モデル（LLM）**が採用されています。代表的なものは以下の通りです。

- **GPT-4（OpenAI社）:** Microsoft GitHub Copilot Chatなどで採用されている最新の汎用LLMです。VS Code上のCopilot Chat（Copilot X）もGPT-4ベースで動作しており【28†L1-L4】、Figma MCPサーバーと連携してデザイン文脈をコード生成に活かすことができます。GPT-4は**高いコーディング能力と推論力**を持ちますが、制約として**入力コンテキスト長に上限**があります。標準では約8kトークン（32kトークンの拡張版も限定提供）とされ、長大なファイルや複数画面にまたがる巨大なデザインコンテキストを一度に渡すには不向きです【25†L111-L119】。またAPI利用には料金が高めで、応答速度もGPT-3.5系より遅い傾向があります。そのため、小規模なUI部品の生成には迅速なGPT-3.5を使い、大きな画面の整合性チェックや高度なリファクタリングにはGPT-4を使う、というように**タスクに応じモデルを使い分ける**ことも考えられます【14†L53-L58】。

- **Claude 2（Anthropic社）:** Anthropic社の提供するLLMで、特に**大容量のコンテキスト**を扱えるのが強みです。Claudeの最新モデルは最大100k〜200kトークン規模の文脈を保持可能とされ【25†L111-L119】、プロジェクト全体のコードベースや複数のFigma画面の情報を一度に取り込みつつコード生成・編集できるポテンシャルがあります。CursorはAnthropic社のClaudeもサポートしており、ユーザーはGPT系列とClaude系列を選択可能です【28†L1-L4】。実際、Cursorコミュニティでは「コーディング目的ではClaudeが依然として最強である」と評価する声もあります【14†L53-L58】。Claudeは**一度に大量の情報を読む**ことに長けているため、デザインシステム全体をコンテキストに含めても破綻しにくいですが、一方で長文脈モードでは**応答に時間がかかる**・**費用が高い**という制限があります【25†L111-L119】（Anthropicの大規模モデルはトークン単価も高く、利用プラットフォームによっては1日に一定回数までなど制限が課される場合もあります）。Claudeを利用するには、Anthropic提供のエディタ「Claude Code」やCLIツール経由でMCPサーバーを登録する方法もあります【6†L244-L253】。Claude Code CLIでは`claude mcp add ...`のようなコマンドでFigma MCPサーバーを追加し、ターミナル上で対話できます【6†L244-L252】。

- **その他のモデル:** 上記2つが現状MCP活用で中心的なLLMですが、CursorではGPT-3.5（OpenAI社）やClaude Instant（Anthropic社の軽量版）なども利用できます。GPT-3.5系は**高速応答かつ低コスト**で、小規模なタスクに有用ですが、コンテキスト上限が4k〜16k程度と狭いため複雑なデザイン全体の理解には限界があります。一方、AnthropicのClaude Instantはコンテキストは比較的小さいものの応答が速くコストも低いモデルです。いずれにせよ、**MCP経由で使うモデルはMCPクライアント側で選択**されるものであり、プロトコル自体はモデル種類を問いません。将来的には他のモデル（例: Llama 2等のローカルモデル）でも、MCPクライアントと組み合わせればFigma MCPサーバーを利用できる可能性があります。

**モデル利用時の制限事項:**  
各モデルには上記のように**トークン長や応答時間、精度面の特徴**があり、用途に応じた選択が重要です。特に大きな制限として**コンテキストウィンドウの大きさ**が挙げられます。例えば、Claude 2は100k以上のトークンを一度に扱えますが、その文脈をすべて活用できるかは別問題で、あまりに情報が多い場合モデルが重要事項を埋もれさせてしまう「長文脈の曖昧化」も起こり得ます【25†L69-L77】【25†L71-L79】。GPT-4も32k版であっても、履歴を含めるとすぐ上限に達し得るため、不要な情報は適宜要約・切捨てる工夫が必要です【25†L47-L55】。また、モデルの**コード生成品質**にも限界があります。たとえ高性能なGPT-4やClaudeを使っても、一度の生成で完璧なコードが得られることは稀であり、人間によるレビューと追加のプロンプトでの改善が不可欠です【23†L482-L490】【23†L483-L490】。実際、前述の例ではClaudeを用いてもレイアウト再現度は70〜80%程度で、微調整や動作追加が必要でした【23†L482-L490】。このように**「AI任せで全自動」とはいかない点**が現在のモデルの限界です。またモデルは**画像を直接認識できない**（テキストのみ処理）場合が多く、Figma MCPサーバーが返すスクリーンショット（base64形式画像）は、2025年時点ではGPT-4など大半のモデルでテキストとして扱われるだけで視覚的に解析できません【10†L241-L249】【10†L243-L251】。（GPT-4の画像解析版など一部例外もありますが、開発ツールでは未統合。）そのためMCPサーバーは画像以外の情報も合わせて提供し、モデルがテキストとしてデザイン意図を理解できるよう工夫されています【5†L195-L203】【5†L197-L204】。

加えて、各モデルの利用には**サービス側の制約**もあります。GitHub Copilot経由のGPT-4利用では1分あたりの呼び出し回数やトークン量に内部制限があったり、CursorでのClaude利用でも月内使用量に上限やレート制限が設定されたプランがあります【24†L19-L23】。したがって、大規模プロジェクトで継続的にMCP＋LLMを活用する場合、**コスト管理や利用配分**も念頭に置く必要があります。

以上を踏まえ、GPT-4やClaudeなど複数モデルを状況に応じて使い分け、各モデルの強み（精度や文脈サイズ）を活かしつつ制約（遅さ・費用・不完全さ）を補う形で開発フローに組み込むことが重要です。

## 5. フロントエンドエンジニア向けの実践的活用事例と開発フローへの統合、ベストプラクティス

**活用事例（デザイン to コードの自動化）:** フロントエンドエンジニアがMCPサーバーを活用する最も代表的なケースは、**デザインからのコーディング自動化**です。例えば新機能のUIデザインがFigmaで用意された際、従来はデザイナーから受け取ったコンポーネントの寸法・カラーを手作業でCSS/JSXに起こしていました。MCPサーバーとCursor等のAIツールを統合すれば、この**デザイン→コードの変換をAIに下ごしらえさせる**ことができます【20†L369-L377】【20†L375-L383】。Builder.ioのブログでは、実際にMaterial 3デザインキット内の画面モックアップをFigma MCPサーバー＋Cursor (Claudeモデル)でReactコードに変換する例が紹介されています【20†L379-L387】【20†L391-L399】。4分ほどでチャットアプリ風UIの主要コンポーネントが生成され、開発者はその後数回のプロンプトでイベント処理の追加やスタイルの調整を行い、最終的に動くコードを完成させています【23†L479-L487】【23†L483-L490】。この例では、退屈な骨組み作りをAIに任せ、人間は仕上げと品質管理に集中するという**役割分担**が実現できています【23†L487-L495】。

**開発フローへの統合:** MCPサーバーを導入した開発フローでは、次のようなステップが統合ポイントとなります。

- **デザイン段階:** デザイナーと協力し、Figma上でのデザイン構造をできるだけ**コード化しやすい形に整理**します。具体的には、再利用要素はコンポーネント化し、グローバルなカラー・スペース値は変数（デザイントークン）化するなど、Figmaファイル自体を整備します【8†L402-L410】。またレイヤー名は意味を持つ名前（例：「CardContainer」）にし、Auto Layoutでレスポンシブ挙動を示す等、**設計意図がメタ情報から伝わる状態**にするのが望ましいです【8†L407-L415】【8†L409-L417】。このように構造化されたFigmaであれば、MCP経由で取得されるデータも有用なものになります。

- **実装計画段階:** 開発者はまずデザインを俯瞰し、どの部分をAI生成に任せるか見極めます。**小さく独立したUIパーツ**（ボタン、カードなど）は個別に生成させ、大きな画面はセクションごとに分割して順次生成→組み合わせる戦略が有効です【8†L519-L528】。またプロジェクトの技術スタック（React+Tailwindなのか、Vueなのか等）に合わせて、AIへの指示テンプレートを用意します。例えば「当社のUIフレームワークChakra-UIを使用して実装せよ」「レイアウトは当社のStackコンポーネントで組め」等、**プロジェクト固有のルール**をプロンプトに盛り込む計画を立てます【8†L424-L432】【8†L432-L439】。

- **AIコーディング段階:** 前述のワークフローに沿ってCursorなどでAIにコーディングさせます。この際、**プロンプトエンジニアリング**が成果物の品質を左右します【8†L419-L427】。良いプロンプトのコツとして、以下が挙げられます【8†L424-L433】【8†L432-L439】:
  - フレームワークやスタイリングの指定: 「Next.js + Tailwindで実装してください」「Vue3 Composition APIで書いて」等。
  - プロジェクト構造の指示: 「コードは`src/components/ui`配下に追加して」「既存の`Header.tsx`を修正して組み込んで」等。
  - レイアウト/デザイン指針: 「当社のGridシステムを使って」「余白はデザイントークンの値を使用して」等。
  - 守ってほしいルール: 「直接色値をハードコーディングしないこと」「ARIA属性を適切に付与すること」等。

  こうした指示を与えることで、AIは**よりプロジェクトに即したコード**を生成しやすくなります【8†L424-L432】。プロンプトは丁寧に、まるで新メンバーに仕様を伝えるかのように書くと効果的だとされています【8†L432-L439】。

- **レビュー・テスト段階:** AIが出力したコードはCIでテストや型チェックを走らせ、人間がコードレビューも行います。ここで**デザインとの乖離や不要なハードコーディング**がないかチェックします。幸い、MCPサーバーを使っている場合は色・タイポグラフィ・ブレークポイント等が変数化されているので、ハードコーディングは少ない傾向にあります。しかし、デザインシステムにない値が使われていないか（AIが勝手に12pxのマージンを入れていないか）などは確認し、必要なら修正します【23†L523-L531】。また**コンポーネントの再利用**も重視ポイントです。AIが一から新規UIコードを書きすぎていないかを見て、可能なら共通化や既存コンポーネントへの置き換えを行います（Code Connect情報が正しく設定されていれば、AIは適切に既存コンポーネントを使おうとしますが、完全ではありません【23†L523-L531】）。

- **反復改善:** 開発チーム内でこのMCP＋AIフローを回しながら、**ベストプラクティス**を洗練させていきます。例えば「Figma側でここまで作っておけばAIの出力精度が高い」といった知見や、「頻出する修正事項はCursorのルールファイルに追記してAIに守らせる」といったノウハウです【8†L469-L478】【8†L481-L489】。Cursorでは`.cursor/rules`ディレクトリにMDCルールファイルを作成し、常に適用・自動付与・Agent要求時適用・Manualのみ など適用範囲を選べます【8†L471-L479】【25†L101-L109】。ここに「画像やSVGはMCPサーバーのローカルパスを使うこと」「デザイントークンがある場合はそれを必ず使用すること」等、プロジェクト固有のガイドラインを記述しておけば、以後のAI提案に一貫性が生まれます【8†L481-L489】。一度ルール化すれば毎回プロンプトで指示せずとも適用されるため**開発フローに深く統合**できます【8†L509-L517】。

**ベストプラクティスまとめ:**  
- *デザインファイル編:* 再利用部分はコンポーネント化し、色・余白・フォントは変数化。レイヤー名は意味のある名称にし、Auto Layout等でレスポンシブな意図を明示【8†L402-L410】【8†L409-L417】。視覚からは伝わらない動作はFigmaの注釈やデベロッパーメモに書いておく【8†L411-L418】。
- *プロンプト編:* AIへの指示は**簡潔かつ具体的**に。フレームワーク/ライブラリ名やプロジェクトルールを明記し、出力コードの配置先や変更対象ファイルも可能なら指定【8†L424-L432】【8†L432-L439】。曖昧な表現を避け、チームメイトにタスクを依頼するような口調で明確に期待結果を伝える【8†L432-L439】。
- *ツール活用編:* AIがうまくコンテキストを取れていないと感じたら、**手動でツールを明示的に呼ぶ**ことも検討する。例えば「トークン名ではなく生の値が出てきてしまう」という場合、「このフレームで使われている変数名と値を一覧してください」と`get_variable_defs`を使うよう促すと良い【8†L443-L451】【8†L453-L458】。AIが自動では適切なツールを選べないこともあるため、プロンプトで**どの情報を取得・利用すべきか指示**するテクニックも有用です。
- *ガイドライン編:* 繰り返し出てくるプロジェクト固有ルールはCursorの**ルールファイル**に記述して自動適用させる【8†L469-L478】【8†L481-L489】。例えば「画像アセットは必ずMCPサーバーが返すローカルパスを使う」「デザインシステムのコンポーネントがある場合新規作成せずそれを使う」「アクセシビリティ基準WCAGに準拠する」といったルールを共有し、AI提案のブレを抑制します【8†L481-L489】【8†L493-L501】。こうした*ワンソース・マルチユース*的な指示集約は、チーム全員がAIを使う際のばらつきを減らし生産性向上に寄与します【8†L509-L517】。
- *スコープ制御編:* 一度に大量のコンテキストを処理させようとしないこと。**画面は部品に分割**し、複数回に分けてコード生成する【8†L519-L528】。大きすぎる選択範囲はモデルを混乱させ、応答遅延や失敗につながります【8†L521-L529】。もしAIの応答が明らかに遅かったり不完全な場合、選択範囲を縮小して再試行することも検討しましょう【8†L525-L532】。

以上のベストプラクティスを踏まえると、Figma MCPサーバー＋AIはフロントエンド実装の強力な相棒となります。ただし**「お任せで完了」ではなく、開発者のガイドと調整を経て初めて実用レベルのコードになる**点を忘れず、適切に人がハンドルしながら活用することが重要です【23†L523-L531】【23†L533-L541】。

## 6. Cursor・Figma・MCPを組み合わせる際のTipsや注意点

最後に、これらツール群を効果的に併用するためのTipsや注意点をまとめます。

- **環境と権限の準備:** Figma MCPサーバーは**Figmaデスクトップアプリ上でのみ稼働**し、使用には該当プランのDev Mode権限が必要です【1†L125-L133】。Web版Figmaでは動作しません。またVS Codeの場合GitHub Copilotの有効化が必須（Copilot Chatがエージェント機能を持つため）といった前提条件もあります【1†L205-L213】。使用前に各ツールの要件（対応エディタのバージョン、APIキー設定など）を満たしているか確認してください。

- **MCPサーバー接続確認:** MCPサーバーを有効化したら、**まずエディタ側でサーバーが認識されているか**確認しましょう。Cursorの場合、Agentモードのチャット画面右側に「Available Tools: Figma ...」のようにツール一覧が表示されます【6†L298-L307】。VS Codeの場合はCopilotチャットを開き、AgentモードにしてツールメニューにFigma MCPのツールが出ているか確認します【1†L199-L207】。出ていなければFigmaやエディタを再起動する、設定JSONを再チェックするなどして**接続状態を正してください**【6†L202-L210】【6†L204-L213】。

- **選択とリンクの使い分け:** 前述しましたが、**Figma側で何を選択しているか**が非常に重要です。MCPサーバーは常に選択中ノード（もしくは要求されたnode-id）の情報のみ返します【6†L298-L307】。誤ったレイヤーを選択していると意図しない部分のコードが生成される可能性があります。慣れないうちは、Figmaで対象フレームを選択した状態で「この選択をコードにしてください」といった直接的な指示を使い、きちんとその選択名称がAIの返答に出てくるか確認するとよいでしょう（例: 「`Frame 42`を検出しました…」等）。また一度に複数フレームを選択すると動作しないため、**必ず1つずつ**処理します【23†L475-L483】。

- **Auto-runモードの活用:** Cursorでは、MCPツール実行時に都度ユーザー承認を要求する仕様ですが、開発に慣れてきたら**Auto-run（Yoloモード）を有効化**すると効率が上がります【10†L219-L227】。これによりAIエージェントが**ユーザーの指示に応じ自動でMCPツールを実行し、即座に結果を返せる**ようになります。ただし大量のツール呼び出しが行われる場合もあるため、挙動をしばらく監視して問題ないことを確認してから常用すると良いでしょう【10†L219-L227】【25†L121-L129】。（長いツール実行チェーンは25回で確認ダイアログが出る仕様もあります【25†L121-L129】。）

- **画像ツールのトークン管理:** Figma MCPサーバーには`get_image`ツール（選択部分のスクリーンショットを取得）があり、デフォルトで有効です【6†L363-L371】。これはレイアウトの忠実性を補完するのに役立ちますが、**画像データはトークン容量を圧迫**します。コンテキストが肥大化してきた場合やモデルが画像を活用できていない場合、一時的に「Preferences > Dev Mode MCP Server Settings」で`get_image`ツールを無効化することも検討してください【6†L363-L371】【6†L377-L385】。代わりに「Use placeholders」設定をオンにすると画像取得をスキップしプラシーホルダーで埋めることもできます【6†L375-L383】。トークン節約と情報量のバランスを見て調整しましょう。

- **Code Connectと変数の活用:** **デザインとコードを繋ぐ情報**を最大限活用することが高品質な出力の鍵です。可能なら開発前にFigma上でコンポーネントとコードの対応関係（Code Connect）や変数のコード表現（デザイントークンのCSS変数名など）を設定しておくと良いでしょう【5†L189-L197】【5†L195-L199】。MCPサーバー設定で「Enable code connect」を有効にすれば、AIが出力コード内で正確に`import { Button } from 'src/components/Button'`のようなコードを挿入してくれる可能性が高まります【8†L403-L410】【5†L189-L197】。逆にこれらが無い状態だと、AIは既存コンポーネントを見つけられず独自に似たコードを新規作成してしまうことがあります【5†L186-L194】【5†L189-L197】。結果として後から置換・修正の手間が増えるので、**事前の紐付け設定**を怠らないでください。

- **出力コードの検証:** AIの生成したコードは**必ず実行して確認**しましょう。MCPエージェントは現在、自身が書いたコードを実際にレンダリングしたり挙動を検証する能力がありません【23†L523-L531】。つまり「デザインどおり画面に表示されたか」をチェックできるのは人間だけです。そのため、一連の生成が終わったらローカル環境でアプリを起動し、**デザインと照合しながらUIを確認**します。グローバルなCSSの影響で意図せぬスタイル崩れが起きていないか、コンポーネントが正しく配置されているか等を目視で検証し、必要ならAIに追加指示するか自分でコードを修正します【23†L523-L531】【23†L525-L533】。AIが「完璧に理解したつもり」であっても環境依存の問題や見落としは発生します。この工程を疎かにすると不具合の原因を後から探す羽目になります。

- **過信しない:** MCP＋AIは強力ですが、**万能ではない**ことをチーム全体で共有しましょう。現時点のワークフローはFigmaとコードベースの間にある「翻訳レイヤー」に過ぎず、常に開発者の監督が必要です【23†L539-L547】【23†L535-L543】。特にデザインシステムにないイレギュラーなデザインや、新規ウィジェット的なUIはAIが的外れなコードを生成しがちです（創意工夫を発揮してしまう）【23†L523-L531】【23†L529-L537】。またチーム開発ではデザイナーやPMがこのプロセスに直接関与できない（最終的にコードをマージするのは開発者だけ）ことも、現状の制約です【23†L531-L539】。これらを踏まえ、「下流工程の効率化ツール」と位置づけて、**レビューとコラボレーションのプロセスは省略しない**ことが肝心です。

以上のTipsを守りつつ、Cursor・Figma・MCPサーバーを組み合わせれば、UI実装の速度と品質を飛躍的に向上させることができます。初期セットアップや学習コストはありますが、適切な使い方を身につければ「デザインの意図に沿ったコード」を短時間で得ることができるため、大規模プロジェクトや迅速なプロトタイピングで強い武器となるでしょう。【23†L539-L547】 継続的にベータ版のフィードバックを送りつつ、これらツールの成熟とともにチームの開発プロセスをアップデートしていくことが重要です。
